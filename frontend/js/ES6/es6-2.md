**Table of Contents** _generated with [DocToc](https://github.com/thlorenz/doctoc)_

- [class](#class)
  - [1. 类和原型](#1-%E7%B1%BB%E5%92%8C%E5%8E%9F%E5%9E%8B)
  - [2. 构造函数: 标识[instanceof、classof、in]、constructor property](#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%A0%87%E8%AF%86instanceofclassofinconstructor-property)
  - [3. 继承:](#3-%E7%BB%A7%E6%89%BF)
  - [4. 类扩展: 类的扩展是通过给原型对象添加新方法](#4-%E7%B1%BB%E6%89%A9%E5%B1%95-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95%E6%98%AF%E9%80%9A%E8%BF%87%E7%BB%99%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%96%B9%E6%B3%95)
  - [5. 类与类型: instanceof、constructor property、constructor name、鸭式辩解](#5-%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%9E%8B-instanceofconstructor-propertyconstructor-name%E9%B8%AD%E5%BC%8F%E8%BE%A9%E8%A7%A3)
  - [6. 面向对象技术: 集合类、枚举类、标准方法转换、比较、借用、重载、工厂方法](#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF-%E9%9B%86%E5%90%88%E7%B1%BB%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%A0%87%E5%87%86%E6%96%B9%E6%B3%95%E8%BD%AC%E6%8D%A2%E6%AF%94%E8%BE%83%E5%80%9F%E7%94%A8%E9%87%8D%E8%BD%BD%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95)
  - [7. 子类: 定义/constructor、方法链/组合[代替继承]、子类/层次、抽象类](#7-%E5%AD%90%E7%B1%BB-%E5%AE%9A%E4%B9%89constructor%E6%96%B9%E6%B3%95%E9%93%BE%E7%BB%84%E5%90%88%E4%BB%A3%E6%9B%BF%E7%BB%A7%E6%89%BF%E5%AD%90%E7%B1%BB%E5%B1%82%E6%AC%A1%E6%8A%BD%E8%B1%A1%E7%B1%BB)
  - [8. ECMA5 中的类](#8-ecma5-%E4%B8%AD%E7%9A%84%E7%B1%BB)
- [Set 和 Map 数据结构](#set-%E5%92%8C-map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
  - [1. Set](#1-set)
  - [2. WeakSet](#2-weakset)
  - [3. Map](#3-map)
  - [4. WeakMap](#4-weakmap)
- [Promise 对象](#promise-%E5%AF%B9%E8%B1%A1)
  - [1. Promise 的含义](#1-promise-%E7%9A%84%E5%90%AB%E4%B9%89)
  - [2. 基本用法](#2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95)
  - [3. Promise.prototype.then()](#3-promiseprototypethen)
  - [4. Promise.prototype.catch()](#4-promiseprototypecatch)
  - [5. Promise.prototype.finally()](#5-promiseprototypefinally)
  - [6. Promise.all()](#6-promiseall)
  - [7. Promise.race()](#7-promiserace)
  - [8. Promise.resolve()](#8-promiseresolve)
  - [9. Promise.reject()](#9-promisereject)
  - [10. 应用](#10-%E5%BA%94%E7%94%A8)
  - [11. Promise.try()](#11-promisetry)
- [async 函数](#async-%E5%87%BD%E6%95%B0)
  - [1. 含义](#1-%E5%90%AB%E4%B9%89)
  - [2. 基本用法](#2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1)
  - [3. 语法](#3-%E8%AF%AD%E6%B3%95)
  - [4. async 函数的实现原理](#4-async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
  - [5. 与其他异步处理方法的比较](#5-%E4%B8%8E%E5%85%B6%E4%BB%96%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83)
  - [6. 实例: 按顺序完成异步操作](#6-%E5%AE%9E%E4%BE%8B%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C)
  - [7. 异步遍历器](#7-%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8)
- [Iterator 和 for...of 循环](#iterator-%E5%92%8C-forof-%E5%BE%AA%E7%8E%AF)
  - [1. Iterator（遍历器）的概念](#1-iterator%E9%81%8D%E5%8E%86%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5)
  - [2. 默认 Iterator 接口](#2-%E9%BB%98%E8%AE%A4-iterator-%E6%8E%A5%E5%8F%A3)
  - [3. 调用 Iterator 接口的场合](#3-%E8%B0%83%E7%94%A8-iterator-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9C%BA%E5%90%88)
  - [4. 字符串的 Iterator 接口](#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84-iterator-%E6%8E%A5%E5%8F%A3)
  - [5. Iterator 接口与 Generator 函数](#5-iterator-%E6%8E%A5%E5%8F%A3%E4%B8%8E-generator-%E5%87%BD%E6%95%B0)
  - [6. 遍历器对象的 return(), throw()](#6-%E9%81%8D%E5%8E%86%E5%99%A8%E5%AF%B9%E8%B1%A1%E7%9A%84-returnthrow)
  - [7. for...of 循环](#7-forof-%E5%BE%AA%E7%8E%AF)
- [Generator 函数的语法](#generator-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95)
  - [1. 简介](#1-%E7%AE%80%E4%BB%8B)
  - [2. next 方法的参数](#2-next-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0)
  - [3. for...of 循环](#3-forof-%E5%BE%AA%E7%8E%AF)
  - [4. Generator.prototype.throw()](#4-generatorprototypethrow)
  - [5. Generator.prototype.return()](#5-generatorprototypereturn)
  - [6. next()、throw()、return() 的共同点](#6-nextthrowreturn-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9)
  - [7. yield\* 表达式](#7-yield%5C-%E8%A1%A8%E8%BE%BE%E5%BC%8F)
  - [8. 作为对象属性的 Generator 函数](#8-%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84-generator-%E5%87%BD%E6%95%B0)
  - [9. Generator 函数的 this](#9-generator-%E5%87%BD%E6%95%B0%E7%9A%84-this)
  - [10. 含义](#10-%E5%90%AB%E4%B9%89)
  - [11. 应用](#11-%E5%BA%94%E7%94%A8)
- [Generator 函数的异步应用](#generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8)
  - [1. 传统方法](#1-%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95)
  - [2. 基本概念](#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
  - [3. Generator 函数](#3-generator-%E5%87%BD%E6%95%B0)
  - [4. Thunk 函数](#4-thunk-%E5%87%BD%E6%95%B0)
  - [5. co 模块](#5-co-%E6%A8%A1%E5%9D%97)
- [Module 的语法 Module 的加载实现](#module-%E7%9A%84%E8%AF%AD%E6%B3%95-module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0)
  - [1. 概述](#1-%E6%A6%82%E8%BF%B0)
  - [2. 严格模式](#2-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F)
  - [3. export 命令](#3-export-%E5%91%BD%E4%BB%A4)
  - [4. import 命令](#4-import-%E5%91%BD%E4%BB%A4)
  - [5. 模块的整体加载](#5-%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B4%E4%BD%93%E5%8A%A0%E8%BD%BD)
  - [6. export default 命令](#6-export-default-%E5%91%BD%E4%BB%A4)
  - [7. export 与 import 的复合写法](#7-export-%E4%B8%8E-import-%E7%9A%84%E5%A4%8D%E5%90%88%E5%86%99%E6%B3%95)
  - [8. 模块的继承](#8-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%A7%E6%89%BF)
  - [9. 跨模块常量](#9-%E8%B7%A8%E6%A8%A1%E5%9D%97%E5%B8%B8%E9%87%8F)
  - [10. import()](#10-import)
- [Class 的基本语法](#class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95)
  - [1. 简介](#1-%E7%AE%80%E4%BB%8B-1)
  - [2. 静态方法](#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95)
  - [3. 实例属性的新写法](#3-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B0%E5%86%99%E6%B3%95)
  - [4. 静态属性](#4-%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7)
  - [5. 私有方法和私有属性](#5-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7)
  - [6. new.target 属性](#6-newtarget-%E5%B1%9E%E6%80%A7)
- [Class 的继承](#class-%E7%9A%84%E7%BB%A7%E6%89%BF)
  - [1. 简介](#1-%E7%AE%80%E4%BB%8B-2)
  - [2. Object.getPrototypeOf()](#2-objectgetprototypeof)
  - [3. super 关键字](#3-super-%E5%85%B3%E9%94%AE%E5%AD%97)
  - [4. 类的 prototype 属性和**proto**属性](#4-%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8Cproto%E5%B1%9E%E6%80%A7)
  - [5. 原生构造函数的继承](#5-%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF)
  - [6. Mixin 模式的实现](#6-mixin-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0)
- [编程风格](#%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC)
  - [1. 块级作用域](#1-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F)
  - [2. 字符串](#2-%E5%AD%97%E7%AC%A6%E4%B8%B2)
  - [3. 解构赋值](#3-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC)
  - [4. 对象](#4-%E5%AF%B9%E8%B1%A1)
  - [5. 数组](#5-%E6%95%B0%E7%BB%84)
  - [6. 函数](#6-%E5%87%BD%E6%95%B0)
  - [7. Map 结构](#7-map-%E7%BB%93%E6%9E%84)
  - [8. Class](#8-class)
  - [9. 模块](#9-%E6%A8%A1%E5%9D%97)
  - [10. ESLint 的使用](#10-eslint-%E7%9A%84%E4%BD%BF%E7%94%A8)

### class

#### 1. 类和原型

- 任何类方法[自动默认传入参数: 母体对象]都可通过 this 来读取对象属性

#### 2. 构造函数: 标识[instanceof、classof、in]、constructor property

- 用来初始化新建的类; 原型为: 构造函数名.prototype
- constructor 属性: 在 Object.prototype[7 个]中唯一一个不可枚举属性; constructor 的值是一个函数对象;

  ```js
  F.prototype.constructor === F; //恒成立
  var o = new f();
  o.constructor === F; //true
  ```

- 如何定义一个类:

  1. 先定义一个构造函数,并初始化
  2. 给构造函数的 prototype 定义实例方法[内: 工厂方法; 外{重写/添加}:]
  3. 给构造函数定义类字段、属性

  ```js
  // 方式1: 非构造函数
  function range(from, to) {
    // 使用 inherit() 函数来创建对象
    var r = inherit(range.methods);
    r.from = from;
    r.to = to;
    return r;
  }
  // 原型对象定义工厂方法被继承
  range.methods = {
    includes: function(x) {
      return this.from <= x && x <= this.to;
    },
    foreach: function(f) {
      for (var x = Math.ceil(this.from); x <= this.to; x++) f(x);
    },
    toString: function() {
      return '(' + this.from + '...' + this.to + ')';
    }
  };
  // 使用
  var r = range(1, 3); // 创建一个范围对象
  r.includes(2); // => true: 2 在这个范围内
  r.foreach(console.log); // 输出 1 2 3
  console.log(r); // 输出(1...3)

  // 方式2: 类 = 使用构造函数 + 构造函数名.prototype
  function range(from, to) {
    this.from = from;
    this.to = to;
  }
  range.prototype = {
    includes: function(x) {
      return this.from <= x && x <= this.to;
    },
    foreach: function(f) {
      for (var x = Math.ceil(this.from); x <= this.to; x++) f(x);
    },
    toString: function() {
      return '(' + this.from + '...' + this.to + ')';
    }
  };

  // 方式3: defineClass(三参数: constructor、methods、statics)
  var SimpleRange = defineClass(
    function(f, t) {
      this.f = f;
      this.t = t;
    },
    {
      includes: function(x) {
        return this.f <= x && x <= this.t;
      },
      toString: function() {
        return this.f + '...' + this.t;
      }
    },
    {
      upto: function(t) {
        return new SimpleRange(0, t);
      }
    }
  );
  ```

#### 3. 继承:

- 在 JavaScript 中函数都是以值的形式出现的, 方法和字段没有什么区别. 如果属性值为函数, 那么这个属性就定义了一个方法; 否则就是一普通属性。
- JavaScript 中三种不同的对象: 构造函数对象、原型对象、实例对象。

#### 4. 类扩展: 类的扩展是通过给原型对象添加新方法

- JavaScript 中继承是动态的: 对象从原型继承后; 原型改变, 对象也随之而变
- 可以通过给 Object.prototype 添加方法是所有对象继承[不推荐]; 推荐使用 Object.defineProperty(3 参数:object、propertyName、特征)扩展 object.prototype
- 类的扩展是通过给原型对象添加新方法

  ```js
  String.prototype.trim = String.prototype.trim
    || function() {
      if (!this) return this;
      return this.replace(/^s+|s+$/g, '');
    };

  Function.prototype.getName = function() {
    return this.name || this.toString().match(/functions*([^()*](/)[1])/);
  };
  ```

#### 5. 类与类型: instanceof、constructor property、constructor name、鸭式辩解

- JavaScript 中数据类型: null、undefined、true/false、Number、String、function、object
- isPropertyof()://是否存在特定的原型对象
  ```js
  range.methods.isPropertyof(r); //true 判断r是否是range的实例
  ```
- constructor 属性: 识别对象是否属于某个类
  ```js
  function typeAndValue(x) {
    if (x == null) return ''; // Null 和 undefined 没有构造函数
    //函数对象; 而 typeof 返回字符串
    switch (x.constructor) {
      case Number:
        return 'Number: ' + x; // 处理原始类型
      case String:
        return "String: '" + x + "'";
      case Date:
        return 'Date: ' + x; // 处理内置类型
      case RegExp:
        return 'Regexp: ' + x;
      case Complex:
        return 'Complex: ' + x; // 处理自定义类型
    }
  }
  ```
- 鸭式辩解: 如果一个对象可以向鸭子一样走路、游泳并且嘎嘎叫, 就认为这个对象是鸭子

#### 6. 面向对象技术: 集合类、枚举类、标准方法转换、比较、借用、重载、工厂方法

- a. 集合类: Set //非重复无序值的集合

  ```js
  function Set() {
    // 构造函数
    this.values = {}; // 数据对象: 名值对
    this.n = 0; // 个数
    this.add.apply(this, arguments);
  }
  Set.prototype.add = function() {
    // 将每个参数都添加至集合中
    for (var i = 0; i < arguments.length; i++) {
      var val = arguments[i];
      var str = Set._v2s(val); // 把它转换为字符串
      if (!this.values.hasOwnProperty(str)) {
        // 不在集合中
        this.values[str] = val; // 将字符串和值对应起来
        this.n++;
      }
    }
    return this; // 支持链式方法调用
  };
  Set.prototype.remove = function() {
    // 从集合删除元素, 这些元素由参数指定
    for (var i = 0; i < arguments.length; i++) {
      var str = Set._v2s(arguments[i]);
      if (this.values.hasOwnProperty(str)) {
        //不能用 in,的话继承属性也是 true
        delete this.values[str]; // 删除它
        this.n--;
      }
    }
    return this; // 支持链式方法调用
  };

  Set.prototype.contains = function(value) {
    return this.values.hasOwnProperty(Set._v2s(value));
  };

  Set.prototype.size = function() {
    return this.n;
  };

  Set.prototype.foreach = function(f, context) {
    for (var s in this.values)
      if (this.values.hasOwnProperty(s))
        // 只自有属性,忽略继承的属性
        f.call(context, this.values[s]); // 调用 f, 传入 value
  };

  // 这是一个内部函数, 用以将任意 JavaScript 值和唯一的字符串对应起来
  Set._v2s = function(val) {
    switch (val) {
      case undefined:
        return 'u'; //特殊的原始值
      case null:
        return 'n'; //值只有一个字母
      case true:
        return 't'; // 代码
      case false:
        return 'f';
      default:
        switch (typeof val) {
          case 'number':
            return '#' + val; // 数字都带有 # 前缀
          case 'string':
            return '"' + val; // 字符串都带有" 前缀
          default:
            return '@' + objectId(val); // Objs and funcs get @
        }
    }

    function objectId(o) {
      var prop = '|**objectid**|'; //私有属性, 用以存放id
      if (!o.hasOwnProperty(prop))
        //如果对象没有id
        o[prop] = Set._v2s.next++; //将下一个值赋给它
      return o[prop]; // 返回这个id
    }
  };
  Set._v2s.next = 100; // 设置初始 id 的值
  ```

- b. 枚举类: 值的有限集合

  ```
  说明enumeration函数有
        values属性: 对象数组
        name属性: 对象
            name属性
            Value属性(值)
        4个方法
            constructor
            tostring
            valueOf
            toJSON
  ```

  ```js
  function enumeration(namesToValues) {
    // 无参时; 这个虚拟的构造函数是返回值
    var enumeration = function() {
      throw "Can't Instantiate Enumerations";
    };
    var proto = (enumeration.prototype = {
      constructor: enumeration, // 标识类型
      toString: function() {
        return this.name;
      },
      valueOf: function() {
        return this.value;
      },
      toJSON: function() {
        return this.name;
      }
    });

    enumeration.values = []; // 对象数组
    for (name in namesToValues) {
      var e = inherit(proto);
      e.name = name;
      e.value = namesToValues[name];
      enumeration[name] = e;
      enumeration.values.push(e);
    }
    enumeration.foreach = function(f, c) {
      for (var i = 0; i < this.values.length; i++) f.call(c, this.values[i]);
    };
    return enumeration;
  }
  ```

- C. 标准方法转换: tostring/toLocalString/valueOf/toJSON

  ```js
    tostring:
        返回可以表示这个对象的字符串
        在期望使用字符串的地方用到了对象则调用
        若没自己实现tostring则调Object.prototype.tostring[Object Object]
    toLocalString:
        以本地敏感的方式将对象转换为字符串
        不重写, 等价于tostring
    valueOf:
        对象转换为原始值
        当数学运算符(除了+)和关系运算符作用于数字文本表示的对象
    toJSON:
        不直接存在object.prototype中
        由JSON.stringify()自动调用   //实现对象序列化
        JSON.Parse()    //还原
  ```

  ```js
  extend(Set.prototype, {
    // 将这些方法添加至Set类的原型对象
    toString: function() {
      // 将集合转换为字符串
      var s = '{',
        i = 0;
      this.foreach(function(v) {
        s += (i++ > 0 ? ', ' : '') + v;
      });
      return s + '}';
    },
    // 类似toString, 但是对于所有的值都将调用toLocaleString()
    toLocaleString: function() {
      var s = '{',
        i = 0;
      this.foreach(function(v) {
        if (i++ > 0) s += ', ';
        if (v == null) s += v;
        // null和undefined
        else s += v.toLocaleString(); // 其他情况
      });
      return s + '}';
    },

    toArray: function() {
      // 将集合转换为值数组
      var a = [];
      this.foreach(function(v) {
        a.push(v);
      });
      return a;
    }
  });
  // 对于要从JSON转换为字符串的集合都被当做数组来对待
  Set.prototype.toJSON = Set.prototype.toArray;
  ```

- d. 比较方法: JavaScript 中 === 比较的是引用而不是值====>看是否指向同一对象

  ```js
  //给Set添加equals方法
  Set.prototype.equals = function(that) {
    if (this === that) return true;
    if (!(that instanceof Set)) return false;
    if (this.size() != that.size()) return false;
    try {
      this.foreach(function(v) {
        if (!that.contains(v)) throw false;
      });
      return true; // 所有的元素都匹配: 两个集合相等
    } catch (x) {
      // 如果集合中有元素在另外一个集合中不存在
      if (x === false) return false;
      throw x; // 重新抛出异常
    }
  };
  ```

- e. 方法调用: 把一个类的方法用到其他类中,可以从类(内置/自写)也可以定义泛型类
  ```js
  //泛型类
  var generic = {
    toString: function() {
      /*代码*/
    },
    equals: function() {
      /*代码*/
    }
  };
  Range.prototype.equals = generic.equals; //方法调用
  ```
- f. 私有状态: 类似 Java 中的 private 私有变量; JavaScript 可以将变量(参数)闭包在一个构造函数中来实现变量私有
  ```js
  function Range(from, to) {
    this.from = from;
    this.to = to;
  }
  Range.prototype = {
    /*重写属性*/
  };
  // 使用
  var r = new Range(1, 5);
  r.from = function() {
    return 0;
  };
  ```
- g. 构造函数重载工厂方法[一个类的方法用以返回类实例必须自己手动调用 nonew]:

  ```js
  function set(...args) {
    this.values = {};
    this.n = 0;
    if (arguments.length == 1 && isArrayLike(arguments[0]))
      this.add.apply(this, arguments[0]);
    else if (arguments.length > 0) this.add.apply(this, arguments);
  }
  set.fromArray = function(a) {
    S = new set();
    S.add.apply(s, a);
    return s;
  };
  set.fromArray([1, 2, 3, 4]);

  function SetFromArray (a){  //constructor
    set.apply(this ,a);
  }
  SetFromArray.prototype=set.prototype;  //将SetFromArray原型设置为Set
  var s=new SetFromArray([1,2,3,4]);
  s instanceOf set ;   //true
  ```

- h. 工厂方法和构造函数区别: 有无 return constructor
  ```js
    1. 工厂方法: set.prototype写在函数内或set.fromArray没有prototype
    2. 工厂方法是直接添加到函数中set.fromArray, 不是添加到set.prototype中
    3. 工厂方法使用时不需要new, 且必须手动调用
    4. 构造函数是要new的, 添加到set.prototype中的函数不需要手动调用
  ```

#### 7. 子类: 定义/constructor、方法链/组合[代替继承]、子类/层次、抽象类

- 具体见 doc 的文档

#### 8. ECMA5 中的类

- 具体见 doc 的文档

### Set 和 Map 数据结构

#### 1. Set

#### 2. WeakSet

#### 3. Map

#### 4. WeakMap

### Promise 对象

#### 1. Promise 的含义

#### 2. 基本用法

#### 3. Promise.prototype.then()

#### 4. Promise.prototype.catch()

#### 5. Promise.prototype.finally()

#### 6. Promise.all()

#### 7. Promise.race()

#### 8. Promise.resolve()

#### 9. Promise.reject()

#### 10. 应用

#### 11. Promise.try()

### async 函数

#### 1. 含义

#### 2. 基本用法

#### 3. 语法

#### 4. async 函数的实现原理

#### 5. 与其他异步处理方法的比较

#### 6. 实例: 按顺序完成异步操作

#### 7. 异步遍历器

### Iterator 和 for...of 循环

#### 1. Iterator（遍历器）的概念

#### 2. 默认 Iterator 接口

#### 3. 调用 Iterator 接口的场合

#### 4. 字符串的 Iterator 接口

#### 5. Iterator 接口与 Generator 函数

#### 6. 遍历器对象的 return(), throw()

#### 7. for...of 循环

### Generator 函数的语法

#### 1. 简介

#### 2. next 方法的参数

#### 3. for...of 循环

#### 4. Generator.prototype.throw()

#### 5. Generator.prototype.return()

#### 6. next()、throw()、return() 的共同点

#### 7. yield\* 表达式

#### 8. 作为对象属性的 Generator 函数

#### 9. Generator 函数的 this

#### 10. 含义

#### 11. 应用

### Generator 函数的异步应用

#### 1. 传统方法

#### 2. 基本概念

#### 3. Generator 函数

#### 4. Thunk 函数

#### 5. co 模块

### Module 的语法 Module 的加载实现

#### 1. 概述

#### 2. 严格模式

#### 3. export 命令

#### 4. import 命令

#### 5. 模块的整体加载

#### 6. export default 命令

#### 7. export 与 import 的复合写法

#### 8. 模块的继承

#### 9. 跨模块常量

#### 10. import()

### Class 的基本语法

#### 1. 简介

#### 2. 静态方法

#### 3. 实例属性的新写法

#### 4. 静态属性

#### 5. 私有方法和私有属性

#### 6. new.target 属性

### Class 的继承

#### 1. 简介

#### 2. Object.getPrototypeOf()

#### 3. super 关键字

#### 4. 类的 prototype 属性和**proto**属性

#### 5. 原生构造函数的继承

#### 6. Mixin 模式的实现

### 编程风格

#### 1. 块级作用域

#### 2. 字符串

#### 3. 解构赋值

#### 4. 对象

#### 5. 数组

#### 6. 函数

#### 7. Map 结构

#### 8. Class

#### 9. 模块

#### 10. ESLint 的使用
